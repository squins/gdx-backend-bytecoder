<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-store, must-revalidate"/>
    <title>Stars - using Bytecoder to transpile Kotlin to WASM</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }


    </style>
    <script src="main.js"></script>
</head>

<body id="body">
<script src="https://cdn.jsdelivr.net/npm/gl-matrix@3/gl-matrix.js"></script>
<script>

    var errorred = function (result) {
        console.log("Error occurred");
        console.log(result)
    }

    var instantiated = function (result) {
        bytecoder.init(result.instance);
        bytecoder.exports.initMemory(0);
        bytecoder.exports.bootstrap(0);
        bytecoder.initializeFileIO();
        var gcInterval = 200;
        var gcMaxObjectsPerRun = 30;
        var gcRunning = false;
        var runcounter = 0;
        setInterval(function() {
            if (!gcRunning) {
                gcRunning = true;
                var freed = bytecoder.exports.IncrementalGC(0, gcMaxObjectsPerRun);
                if (runcounter++ % 10 === 0) {
                    var freemem = bytecoder.exports.freeMem(0);
                    var epoch = bytecoder.exports.GCEpoch(0);
                    console.log(freemem + " bytes free memory after GC, epoch = " + epoch);
                }
                gcRunning = false;
            }
        }, gcInterval);
        bytecoder.exports.main(0);
    };

    function startApp(){
        registerFakeImports();

        WebAssembly.instantiateStreaming(fetch('main.wasm'), bytecoder.imports)
            .catch(errorred)
            .then(instantiated);
    }

    /**
     * Registers fake imports, to prevent crash on start.
     * @Coen: probably not needed now anymore, as we filter out the cards in the Shader plugin
     */
    function registerFakeImports() {
        // bytecoder.imports["bufferutils"] = {
        //     "newDisposableByteBufferINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "freeMemoryByteBuffer": function () {
        //         console.log("FAKE function freeMemoryByteBuffer called");
        //     }
        // };
        // bytecoder.imports["gdx2dpixmap"] = {
        //     "etc1": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "clearLONGINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "setBlendLONGINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "drawPixmapLONGLONGINTINTINTINTINTINTINTINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "freeLONG": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "newPixmapL1LONGINTINTINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "loadL1LONGL1BYTEINTINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "getFailureReason": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     }
        // };
        // bytecoder.imports["etc1"] = {
        //     "etc1": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     }
        // };
        // bytecoder.imports["crc32"] = {
        //     "etc1": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     }
        // };
        // bytecoder.imports["unixfilesystem"] = {
        //     "getLength0String": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "getBooleanAttributes0String": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     }
        // };
        // bytecoder.imports["inflater"] = {
        //     "resetLONG": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "initBOOLEAN": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "inflateBytesBytesLONGL1BYTEINTINTL1BYTEINTINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "inflateBufferBytesLONGLONGINTL1BYTEINTINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "endLONG": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "clearLONGINT": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     },
        //     "initIDs": function () {
        //         console.log("FAKE function newDisposableByteBufferINT called");
        //     }
        // };
    }


</script>
<div id="app"/>
<canvas id="canvas1" width="640" height="480" style="border: 2px solid green;"></canvas>
<button onclick="startApp()">Play</button>

<script>
    let canvas1 = document.getElementById("canvas1");
    canvas1.audio = function(url) {
        console.log(`Play: ${url}`);
        return new Audio(url);
    }
    canvas1.mat4 = function() {
        return glMatrix.mat4;
    }
    canvas1.origin = function() {
        return window.origin
    }
</script>
</body>

</html>